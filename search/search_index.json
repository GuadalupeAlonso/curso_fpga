{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FPGA Design with Verilog","text":""},{"location":"#colaboradores","title":"Colaboradores","text":"<ul> <li>Guadalupe Alonso Contreras - LinkedIn</li> <li>Ciro Fabian Bermudez Marquez - LinkedIn</li> <li>Julisa Verdejo Palacios - LinkedIn</li> </ul>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Existen diversas maneras para trabajar con Verilog, entre las m\u00e1s populares se encuentran:</p> <ul> <li>Aldec-HDL Student Edition</li> <li>Vivado ML Edition</li> <li>Intel Quartus Prime Lite Edition</li> <li>Icarus Verilog</li> </ul> <p>sin embargo, a pesar de que todas estas opciones son gratuitas, no est\u00e1n disponibles en todos los sistemas operativos, en la siguiente tabla se muestran las diferentes compatibilidades:</p> Tabla 1. Compabilidad en diferentes sistemas operativos. Software Linux Windows Mac Aldec-HDL Student Edition \u2713 Vivado ML Edition \u2713 \u2713 Intel Quartus Prime Lite Edition \u2713 \u2713 Icarus Verilog \u2713 \u2713 \u2713 <p>por lo anterior es buena idea comenzar a aprender Verilog utilizando Icarus Verilog, el cual es un compilador libre (open source) para el lenguaje de descripci\u00f3n de hardware IEEE-1364 Verilog. A diferencia de las otras opciones los cuales cuentan con GUI y programas adicionales, Icarus Verilog funciona desde terminal y solo cuenta con herramientas para analizar, compilar y simular el c\u00f3digo Verilog, lo cual es m\u00e1s que suficiente. Las principales ventajas que cuenta esta herramienta son: 1) es muy ligera y f\u00e1cil de instalar, 2) es compatible con diversos sistemas operativos y 3) su compilador es muy robusto, otras herramientas son m\u00e1s permisivas con los errores en el c\u00f3digo.</p> <p>La ventaja de instalar Vivado ML Edition o Intel Quartus Prime Lite Edition es que cuentan con todas las herramientas necesarias para llevar el flujo de dise\u00f1o en FPGA.</p> <pre><code>flowchart LR\n  A[Especificaciones] ==&gt; B[HDL];\n  B ==&gt; C[S\u00edntesis];\n  C ==&gt; D[Place and Route];\n  D ==&gt; E[Verificaci\u00f3n del circuito];\n  B -.-&gt; F[Simulaci\u00f3n];\n  D -.-&gt; G[An\u00e1lisis de tiempo est\u00e1tico];</code></pre>"},{"location":"getting-started/#2-instalacion-de-herramientas","title":"2. Instalaci\u00f3n de herramientas","text":"<p>Para comenzar a trabajar con Icarus Verilog es necesario instalar los siguientes programas:</p> <ul> <li>Instalar un compilador de verilog, Icarus Verilog es el m\u00e1s popular. </li> <li>Para windows  <code>scoop install iverilog</code></li> <li>Para macOS  <code>brew install icarus-verilog</code></li> <li>Instalar un visualizador de forma de onda para verilog. GTKwave es una muy buena opci\u00f3n.</li> <li>Para Windows ya vienen preinstalado con Icarus.</li> <li>Para macOS basta con entrar al siguiente enlace e instalar.</li> <li>Crear los c\u00f3digos  <code>circuit.v</code> y su archivo de simulaci\u00f3n <code>circuit_tb.v</code></li> <li>En el archivo de simulaci\u00f3n es necesario incluir:</li> </ul> <pre><code>`timescale 1ns / 100 ps\n`include \"circuit.v\"\ninitial begin\n$dumpfile(\"circuit_tb.vcd\");\n$dumpvars(0, circuit_tb);\n$display(\"Test complete\");\nend\n</code></pre> <ul> <li>Los comandos a ejecutar son:</li> </ul> <pre><code>iverilog -o circuit_tb.vvp circuit_tb.v\nvvp circuit_tb.vvp\nstart gtkwave\n</code></pre> <p> </p> Figura 1. Nombre de la imagen. <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"getting-started/#links-utiles","title":"links utiles","text":"<ul> <li>Uso de <code>$dumpvars</code> en el enlace</li> <li>C\u00f3mo instalar las herramientas Icarus y GTKwave, video</li> <li>Ejemplo de como utilizar Icarus y GTKwave, video</li> <li>Articulo de c\u00f3mo instalar en macOS, enlace</li> <li>Pagina de verilog, enlace</li> </ul>"},{"location":"blog/","title":"Blog","text":""},{"location":"documentacion/","title":"Documentaci\u00f3n","text":""},{"location":"documentacion/#contenido","title":"Contenido:","text":"<ul> <li> <p>1. Combinacional</p> <ul> <li>1.1. Look Up Tables</li> <li>1.2. Multiplexores</li> <li>1.3. Codificadores</li> <li>1.4. Decodificadores</li> <li>1.5. ROMs</li> <li>1.6. Sumadores</li> <li>1.6. Restadores</li> <li>1.6. Multiplicadores</li> </ul> </li> <li> <p>2. Secuencial</p> <ul> <li>2.1. Flip-Flops</li> <li>2.2. Contadores</li> <li>2.3. FSM Moore</li> <li>2.4. FSM Mealy</li> </ul> </li> <li> <p>3. Teor\u00eda</p> <ul> <li>3.1. Punto Fijo</li> <li>3.2. SCM</li> </ul> </li> </ul>"},{"location":"documentacion/combinacionales/","title":"Combinacional","text":""},{"location":"documentacion/combinacionales/codificador/","title":"Codificadores","text":""},{"location":"documentacion/combinacionales/decodificador/","title":"02. Decodificador","text":""},{"location":"documentacion/combinacionales/decodificador/#que-es-un-decodificador","title":"\u00bfQu\u00e9 es un decodificador?","text":"<p>Un decodificador es un circuito digital que convierte una combinaci\u00f3n de se\u00f1ales de entrada en una se\u00f1al de salida espec\u00edfica.  Su funci\u00f3n principal es descomponer y decodificar una entrada codificada; y activar una \u00fanica salida correspondiente a la combinaci\u00f3n de entrada recibida. Convierte las entradas de datos en \\(n\\) bits en las \\(2^n\\) salidas codificadas.  El decodificador generalmente coloca la l\u00f3gica \\(1\\) n una de sus salidas para crear el c\u00f3digo exacto. Para una combinaci\u00f3n diferente de entradas binarias de \\(n\\) bits, produce una salida codificada de \\(2^n\\). La salida codificada se produce en funci\u00f3n de cada entrada binaria.</p> <p> Figura 1.0. Modelo b\u00e1sico de un decodificador de n entradas.</p>"},{"location":"documentacion/combinacionales/decodificador/#decodificador-para-display-de-7-segmentos","title":"Decodificador para display de 7 segmentos","text":"<p>Los decodificadores de BCD (Decimal Codificado en Binario) a 7 segmentos son muy utilizados para simplificar el uso de los display de 7 segmentos, com\u00fanmente utilizados para mostrar los d\u00edgitos decimales de \\(0\\) a \\(9\\) en una pantalla formada por LED's.</p> <p></p>"},{"location":"documentacion/combinacionales/decodificador/#tabla-de-verdad","title":"Tabla de verdad","text":"\\(num\\) Entrada \\(D\\) Entrada \\(C\\) Entrada \\(B\\) Entrada \\(A\\) Seg \\(a\\) Seg \\(b\\) Seg \\(c\\) Seg \\(d\\) Seg \\(e\\) Seg \\(f\\) Seg \\(g\\) 0 0 0 0 0 1 1 1 1 1 1 1 1 0 0 0 1 0 1 1 0 0 0 0 2 0 0 1 0 1 1 0 1 1 0 1 3 0 0 1 1 1 1 1 1 0 0 1 4 0 1 0 0 0 1 1 0 0 1 1 5 0 1 0 1 1 0 1 1 0 1 1 6 0 1 1 0 1 0 1 1 1 1 1 7 0 1 1 1 1 1 1 0 0 0 1 8 1 0 0 0 1 1 1 1 1 1 1 9 1 0 0 1 1 1 1 0 0 1 1 A 1 0 1 0 1 1 1 0 1 1 1 b 1 0 1 1 0 0 1 1 1 1 1 C 1 1 0 0 1 0 0 1 1 1 0 d 1 1 0 1 0 1 1 1 1 0 1 E 1 1 1 0 1 0 0 1 1 1 1 F 1 1 1 1 1 0 0 0 1 1 1"},{"location":"documentacion/combinacionales/decodificador/#implementacion-en-verilog","title":"Implementaci\u00f3n en Verilog","text":"<p>Para ejemplificar el dise\u00f1o y simulaci\u00f3n de un multiplexor 4 a 1 en lenguaje de programaci\u00f3n Verilog, desarrollaremos diferentes propuesta de c\u00f3digo:</p>"},{"location":"documentacion/combinacionales/decodificador/#primera-propuesta","title":"Primera propuesta","text":"<p>Sintaxis case:</p> <pre><code>module dec7seg (\ninput [3:0] binary,\noutput reg [6:0] leds //lo declaramos como reg porque es una variable\n);\nalways @(binary) begin\ncase (binary)\n4'd0 : leds = 7'b1111110;\n4'd1 : leds = 7'b0110000;\n4'd2 : leds = 7'b1101101;\n4'd3 : leds = 7'b1111001;\n4'd4 : leds = 7'b0110011;\n4'd5 : leds = 7'b1011011;\n4'd6 : leds = 7'b1011111;\n4'd7 : leds = 7'b1110001;\n4'd8 : leds = 7'b1111111;\n4'd9 : leds = 7'b1110011;\n4'd10 : leds = 7'b1110111;\n4'd11 : leds = 7'b0011111;\n4'd12 : leds = 7'b1001110;\n4'd13 : leds = 7'b0111101;\n4'd14 : leds = 7'b1001111;\n4'd15 : leds = 7'b1000111;\ndefault : leds = 7'b0000000;\nendcase\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/decodificador/#segunda-propuesta","title":"Segunda propuesta","text":"<p>Sintaxis if-else:</p> <pre><code>module dec7seg_v2 (\ninput [3:0] binary,\noutput reg [6:0] leds //lo declaramos cono reg porque es una variable\n);\nalways @(binary) begin\nif (binary == 4'd0) begin\nleds = 7'b1111110;\nend else if (binary == 4'd1) begin\nleds = 7'b0110000;\nend else if (binary == 4'd2) begin\nleds = 7'b1101101;\nend else if (binary == 4'd3) begin\nleds = 7'b1111001;\nend else if (binary == 4'd4) begin\nleds = 7'b0110011;\nend else if (binary == 4'd5) begin\nleds = 7'b1011011;\nend else if (binary == 4'd6) begin\nleds = 7'b1011111;\nend else if (binary == 4'd7) begin\nleds = 7'b1110001;\nend else if (binary == 4'd8) begin\nleds = 7'b1111111;\nend else if (binary == 4'd9) begin\nleds = 7'b1110011;\nend else if (binary == 4'd10) begin\nleds = 7'b1110111;\nend else if (binary == 4'd11) begin\nleds = 7'b0011111;\nend else if (binary == 4'd12) begin\nleds = 7'b1001110;\nend else if (binary == 4'd13) begin\nleds = 7'b0111101;\nend else if (binary == 4'd14) begin\nleds = 7'b1001111;\nend else if (binary == 4'd15) begin\nleds = 7'b1000111;\nend else begin\nleds = 7'b0000000;\nend\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/decodificador/#tercera-propuesta","title":"Tercera propuesta","text":"<p>_Sintaxis assign:</p> <pre><code>module dec7seg_v3 (\ninput [3:0] binary,\noutput [6:0] leds\n);\nassign leds = (binary == 4'd0 ) ? 7'b1111110 :\n(binary == 4'd1 ) ? 7'b1111110 :\n(binary == 4'd2 ) ? 7'b1101101 :\n(binary == 4'd3 ) ? 7'b1111001 :\n(binary == 4'd4 ) ? 7'b0110011 :\n(binary == 4'd5 ) ? 7'b1011011 :\n(binary == 4'd6 ) ? 7'b1011111 :\n(binary == 4'd7 ) ? 7'b1110001 :\n(binary == 4'd8 ) ? 7'b1111111 :\n(binary == 4'd9 ) ? 7'b1110011 :\n(binary == 4'd10) ? 7'b1110111 :\n(binary == 4'd11) ? 7'b0011111 :\n(binary == 4'd12) ? 7'b1001110 :\n(binary == 4'd13) ? 7'b0111101 :\n(binary == 4'd14) ? 7'b1001111 :\n(binary == 4'd15) ? 7'b1000111 :\n7'b0000000 ;\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/decodificador/#testbench","title":"TestBench","text":"<p>Simulaci\u00f3n en gtkwave:</p> <pre><code>`timescale 1ns / 100 ps\n`include \"dec7seg.v\"\n`include \"dec7seg_v2.v\"\n`include \"dec7seg_v3.v\"\nmodule dec7seg_tb();\n// Definicion de se\u00f1ales de entrada y salida\nreg [3:0] binary;\nwire [6:0] leds;\n//Instanciacion del modulo\ndec7seg dut(.binary(binary), .leds(leds));\n//dec7seg_v2 dut(.binary(binary), .leds(leds));\n//dec7seg_v3 dut(.binary(binary), .leds(leds));\n// Variables para archivo de salida\ninteger write_data;\ninteger i;\ninitial begin\n// Configuracion de archivos de salida\nwrite_data = $fopen(\"dec7seg_tb_output.txt\",\"w\");\n$dumpfile(\"dec7seg_tb.vcd\");\n$dumpvars(0,dec7seg_tb);\nfor (i = 0; i &lt; 16; i++) begin\nbinary = i; #20\n$fdisplay(write_data,\"Binary = %4b, Leds = %7b\", binary, leds);\nend\n$fclose(write_data);\n$display(\"Test completed\");\nend\nendmodule;\n</code></pre>"},{"location":"documentacion/combinacionales/decodificador/#referencias","title":"Referencias","text":"<ul> <li>(2020, septiembre 16). What is a decoder? Operation, types and applications. https://www.electrically4u.com/what-is-a-decoder-operation-types-and-applications/</li> </ul>"},{"location":"documentacion/combinacionales/look_up_table/","title":"00. Look Up Tables","text":""},{"location":"documentacion/combinacionales/look_up_table/#1-codigos","title":"1. C\u00f3digos","text":""},{"location":"documentacion/combinacionales/look_up_table/#11-ecuacion-booleana","title":"1.1. Ecuaci\u00f3n booleana","text":"lut1.v<pre><code>module lut1(\ninput A,\ninput B,\ninput C,\ninput D,\noutput X\n);\nassign X = (~A &amp; B &amp; ~C) | (A &amp; B &amp; ~C) | (B &amp; ~C &amp; D);\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/look_up_table/#12-diagrama-esquematico","title":"1.2. Diagrama esquem\u00e1tico","text":"lut2.v<pre><code>module lut2(\ninput A,\ninput B,\ninput C,\ninput D,\noutput X\n);\nwire c1;\nwire c2;\nwire c3;\nassign c1 = ~A &amp; B &amp; ~C;\nassign c2 = A &amp; B &amp; ~C;\nassign c3 = B &amp; ~C &amp; D;\nassign  X = c1 | c2 | c3;\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/look_up_table/#13-primitivas-de-verilog","title":"1.3. Primitivas de Verilog","text":"<p>Las compuertas pueden ser de m\u00e1s de dos entradas. lut3.v<pre><code>module lut3(\ninput A,\ninput B,\ninput C,\ninput D,\noutput X\n);\nand(c1,~A, B,~C);\nand(c2, A, B,~C);\nand(c3, B,~C, D);\nor(X,c1,c2,c3);\nendmodule\n</code></pre></p>"},{"location":"documentacion/combinacionales/look_up_table/#14-minterminos","title":"1.4. Mint\u00e9rminos","text":"<p>Tambi\u00e9n se les conoce como suma de productos o SOP (Sum Of Products). lut4.v<pre><code>module lut4(\ninput A,\ninput B,\ninput C,\ninput D,\noutput reg X\n);\nalways @(A,B,C,D) begin\nif ( (~A &amp; ~B &amp; ~C &amp; ~D) | (A &amp; B &amp; C &amp; D) | (A &amp; ~B &amp; ~C &amp; D) ) begin\nX = 1;\nend else begin\nX = 0;\nend\nend\nendmodule\n</code></pre></p>"},{"location":"documentacion/combinacionales/look_up_table/#2-verificacion","title":"2. Verificaci\u00f3n","text":""},{"location":"documentacion/combinacionales/look_up_table/#21-testbench","title":"2.1. Testbench","text":"lut_tb.v<pre><code>`timescale 1ns / 100 ps\n`include \"lut1.v\"\nmodule lut_tb();\n// Definici\u00f3n de se\u00f1ales de entrada y salida\nreg A;\nreg B;\nreg C;\nreg D;\nwire X;\n// Instanciacion del modulo\nlut1 dut(.A(A), .B(B), .C(C), .D(D), .X(X));\n// Variables para archivo, iteraciones y tiempo\ninteger write_data;\ninteger i;\ntime t;\ninitial begin\n// Configuracion de archivos de salida\nwrite_data = $fopen(\"lut_tb_output.txt\",\"w\");\n// Salida de simulacion y variables de salida\n$dumpfile(\"lut_tb.vcd\");\n$dumpvars(0,lut_tb);\n// Configuracion de formato de tiempo\n$timeformat(-9, 2, \" ns\", 10);\n// Simular todas las combinaciones posibles\nfor (i = 0; i &lt; 16; i++) begin\n{A,B,C,D} = i; #20; t = $time;\n$fdisplay(write_data,\"Time = %t, {A,B,C,D} = %b, X = %b\", t, {A,B,C,D}, X);\nend\n// Cerrar archivo de texto\n$fclose(write_data);\n// Terminar simulacion\n$display(\"Test completed\");\n$finish;\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/look_up_table/#22-resultados","title":"2.2. Resultados","text":"lut_tb_output.txt<pre><code>Time =   20.00 ns, {A,B,C,D} = 0000, X = 1\nTime =   40.00 ns, {A,B,C,D} = 0001, X = 0\nTime =   60.00 ns, {A,B,C,D} = 0010, X = 0\nTime =   80.00 ns, {A,B,C,D} = 0011, X = 0\nTime =  100.00 ns, {A,B,C,D} = 0100, X = 0\nTime =  120.00 ns, {A,B,C,D} = 0101, X = 0\nTime =  140.00 ns, {A,B,C,D} = 0110, X = 0\nTime =  160.00 ns, {A,B,C,D} = 0111, X = 0\nTime =  180.00 ns, {A,B,C,D} = 1000, X = 0\nTime =  200.00 ns, {A,B,C,D} = 1001, X = 1\nTime =  220.00 ns, {A,B,C,D} = 1010, X = 0\nTime =  240.00 ns, {A,B,C,D} = 1011, X = 0\nTime =  260.00 ns, {A,B,C,D} = 1100, X = 0\nTime =  280.00 ns, {A,B,C,D} = 1101, X = 0\nTime =  300.00 ns, {A,B,C,D} = 1110, X = 0\nTime =  320.00 ns, {A,B,C,D} = 1111, X = 1\n</code></pre>"},{"location":"documentacion/combinacionales/look_up_table/#4-referencias","title":"4. Referencias","text":"<ol> <li>Russell, \u201cTutorial - Boolean Algebra using Look-Up Tables (LUTs)\u201d, Nandland, el 9 de junio de 2022. https://nandland.com/lesson-4-what-is-a-look-up-table-lut (consultado el 17 de julio de 2023).</li> <li>\u201cQuine\u2013McCluskey algorithm\u201d. https://www.mathematik.uni-marburg.de/~thormae/lectures/ti1/code/qmc (consultado el 17 de julio de 2023).</li> <li>\u201cGate Level Modeling\u201d, ChipVerify. https://www.chipverify.com/verilog/verilog-gate-level-modeling (consultado el 17 de julio de 2023).</li> </ol>"},{"location":"documentacion/combinacionales/memorias_rom/","title":"Memorias ROM","text":""},{"location":"documentacion/combinacionales/multiplexor/","title":"01. Multiplexor","text":""},{"location":"documentacion/combinacionales/multiplexor/#1-codigos","title":"1. C\u00f3digos","text":""},{"location":"documentacion/combinacionales/multiplexor/#11-multiplexor-2-a-1-de-n-bits","title":"1.1 Multiplexor 2 a 1 de n bits","text":"mux2_to_1.v<pre><code>module mux2_to_1 #(\nparameter Width = 32\n) (\ninput  [Width-1:0] in1_i,\ninput  [Width-1:0] in2_i,\ninput              sel_i,\noutput [Width-1:0] mux_o\n);\nassign mux_o = sel_i ? in2_i : in1_i;\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplexor/#11-multiplexor-4-a-1-de-n-bits","title":"1.1 Multiplexor 4 a 1 de n bits","text":"Versi\u00f3n 1Versi\u00f3n 2Versi\u00f3n 3 mux4_to_1.v<pre><code>module mux4_to_1 #(\nparameter Width = 32\n) (\ninput  [Width-1:0] in1_i,\ninput  [Width-1:0] in2_i,\ninput  [Width-1:0] in3_i,\ninput  [Width-1:0] in4_i,\ninput        [1:0] sel_i,\noutput [Width-1:0] out_o\n);\nassign out_o = sel_i[1] ? (sel_i[0] ? in4_i : in3_i) : (sel_i[0] ? in2_i : in1_i);\nendmodule\n</code></pre> mux4_to_1_v2.v<pre><code>module mux4_to_1 #(\nparameter Width = 32\n) (\ninput      [Width-1:0] in1_i,\ninput      [Width-1:0] in2_i,\ninput      [Width-1:0] in3_i,\ninput      [Width-1:0] in4_i,\ninput            [1:0] sel_i,\noutput reg [Width-1:0] out_o\n);\nalways @(in1_i, in2_i, in3_i, in4_i, sel_i) begin\nif (sel_i == 0) begin\nout_o = in1_i;\nend else if (sel_i == 1) begin\nout_o = in2_i;\nend else if (sel_i == 2) begin\nout_o = in3_i;\nend else if (sel_i == 3) begin\nout_o = in4_i;\nend else begin out_o = 0;\nend\nend\nendmodule\n</code></pre> mux4_to_1_v3.v<pre><code>module mux4_to_1 #(\nparameter Width = 32\n) (\ninput      [Width-1:0] in1_i,\ninput      [Width-1:0] in2_i,\ninput      [Width-1:0] in3_i,\ninput      [Width-1:0] in4_i,\ninput            [1:0] sel_i,\noutput reg [Width-1:0] out_o\n);\nalways @(in1_i, in2_i, in3_i, in4_i, sel_i) begin\ncase (sel_i)\n2'd0    : out_o = in1_i;\n2'd1    : out_o = in2_i;\n2'd2    : out_o = in3_i;\n2'd3    : out_o = in4_i;\ndefault : out_o = 0;\nendcase\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplexor/#11-multiplexor-256-a-1","title":"1.1 Multiplexor 256 a 1","text":"mux256_to_1.v<pre><code>module mux256_to_1 (\ninput  [255:0] in_i,\ninput    [7:0] sel_i,\noutput         out_o\n);\nassign out_o = in_i[sel_i];\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplexor/#2-verficacion","title":"2. Verficaci\u00f3n","text":""},{"location":"documentacion/combinacionales/multiplexor/#referencias","title":"Referencias","text":"<ul> <li>Circuitos combinacionales. Introducci\u00f3n. | ELEC02.- Circuitos combinacionales MSI. (s/f). Recuperado el 10 de julio de 2023, de https://ikastaroak.ulhi.net/edu/es/IEA/ELEC/ELEC02/es_IEA_ELEC02_Contenidos/website_5_circuitos_combinacionales_introduccin.html</li> </ul>"},{"location":"documentacion/combinacionales/multiplicador/","title":"05. Multiplicador","text":""},{"location":"documentacion/combinacionales/multiplicador/#implementacion-en-verilog","title":"Implementaci\u00f3n en Verilog","text":"<p>Para ejemplificar el dise\u00f1o y simulaci\u00f3n de un multiplicador en lenguaje de programaci\u00f3n Verilog, desarrollaremos diferentes propuesta de c\u00f3digo en la que se pudiera observar su implementaci\u00f3n de la forma m\u00e1s sencilla posible:</p> <pre><code>module mult #(\nparameter Width = 32\n) (\ninput signed [Width-1:0] a_i,\ninput signed [Width-1:0] b_i,\noutput signed [Width-1:0] mult_o\n);\nwire [Width*2-1:0] temp;\nassign temp = a_i * b_i;\nassign mult_o = temp[52:21];\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/multiplicador/#testbench","title":"TestBench","text":"<pre><code>`timescale 1ns / 100ps\n`include \"mult.v\"\nmodule mult_tb #(\nparameter Width = 32\n) ();\n// Definici\ufffdn de se\ufffdales de entrada y salida\nreg [Width-1:0] a;\nreg [Width-1:0] b;\nwire [Width-1:0] c;\n// Instanciacion del modulo\nmult #(Width) DUT (\n.a_i(a),\n.b_i(b),\n.mult_o(c)\n);\n// Abrir archivo de salida\ninteger write_data;\nlocalparam SF = 2.0**-21.0;\ntime t;\n// Estimulo de las entradas\ninitial begin\nwrite_data = $fopen(\"mult_tb_output.txt\",\"w\");\n$dumpfile(\"mult_tb.vcd\");\n$dumpvars(0,mult_tb);\n$timeformat(-9, 2, \" ns\", 10);\na = 32'b00000000001000000000000000000000; // 1.0\nb = 32'b00000000001000000000000000000000; // 1.0;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b00000000001100000000000000000000; // 1.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b11111111111100000000000000000000; // -0.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n// Cerrar archivo de salida\n$fclose(write_data);\n// Final de simulacion\n$display(\"Test completed\");\n//$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/restador/","title":"04. Restador","text":""},{"location":"documentacion/combinacionales/restador/#que-es-un-restador","title":"\u00bfQu\u00e9 es un restador?:","text":"<p>Dispositivo que resta dos n\u00fameros y produce un resultado, por lo que, un restador digital se ocupa de la resta de d\u00edgitos binarios.  La regla general se ve expresada en la siguiente tabla de verdad:</p> \\(A\\) \\(B\\) \\(y=A-B\\) 0 0 0 0 1 1 1 0 1 1 1 0"},{"location":"documentacion/combinacionales/restador/#restador-completo","title":"Restador completo","text":"<p>Este circuito cuenta con tres entradas y dos salidas, las entradas \\(A\\), \\(B\\) y \\(B_{in}\\) denotan el minuendo, el sustraendo y el pr\u00e9stamo anterior, respectivamente. Las dos salidas, \\(D\\) y \\(B_{out}\\) representan la diferencia y la salida prestada, respectivamente. </p> <p> Figura 1.0. Esquema de un restador completo.</p>"},{"location":"documentacion/combinacionales/restador/#tabla-de-verdad","title":"Tabla de verdad","text":"\\(A\\) \\(B\\) \\(B_{in}\\) \\(D\\) \\(B_{out}\\) 0 0 0 0 0 0 0 1 1 1 0 1 0 1 1 0 1 1 0 1 1 0 0 1 0 1 0 1 0 0 1 1 0 0 0 1 1 1 1 1"},{"location":"documentacion/combinacionales/restador/#semirestador","title":"Semirestador","text":"<p>Cuenta con dos entradas, A y B, y dos salidas que son diferencia y pr\u00e9stamo. La primer salida es la diferencia entre los dos bits de entrada, mientras que la segunda indica si fue necesario tomar prestado durante la resta. </p> <p></p> <p> Figura 2.0. Esquema de un semirestador.</p>"},{"location":"documentacion/combinacionales/restador/#tabla-de-verdad_1","title":"Tabla de verdad","text":"\\(A\\) \\(B\\) \\(Diff\\) \\(Borrow\\) 0 0 0 0 0 1 1 1 1 0 1 0 1 1 0 0"},{"location":"documentacion/combinacionales/restador/#implementacion-en-verilog","title":"Implementaci\u00f3n en Verilog","text":"<p>Para ejemplificar el dise\u00f1o y simulaci\u00f3n de un restador en lenguaje de programaci\u00f3n Verilog, desarrollaremos diferentes propuesta de c\u00f3digo en la que se pudiera observar su implementaci\u00f3n de la forma m\u00e1s sencilla posible:</p> <pre><code>module sub #(\nparameter Width = 32\n) (\ninput signed [Width-1:0] a_i,\ninput signed [Width-1:0] b_i,\noutput signed [Width-1:0] sub_o\n);\nassign sub_o = a_i - b_i;\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/restador/#testbench","title":"TestBench","text":"<pre><code>`timescale 1ns / 100ps\n`include \"sub.v\"\nmodule sub_tb #(\nparameter Width = 32\n) ();\n// Definici\ufffdn de se\ufffdales de entrada y salida\nreg [Width-1:0] a;\nreg [Width-1:0] b;\nwire [Width-1:0] c;\n// Instanciacion del modulo\nsub #(Width) DUT (\n.a_i(a),\n.b_i(b),\n.sub_o(c)\n);\n// Abrir archivo de salida\ninteger write_data;\nlocalparam SF = 2.0**-21.0;\ntime t;\n// Estimulo de las entradas\ninitial begin\nwrite_data = $fopen(\"sub_tb_output.txt\",\"w\");\n$dumpfile(\"sub_tb.vcd\");\n$dumpvars(0,sub_tb);\n$timeformat(-9, 2, \" ns\", 10);\na = 32'b00000000001000000000000000000000; // 1.0\nb = 32'b00000000001000000000000000000000; // 1.0;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b00000000001100000000000000000000; // 1.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b11111111111100000000000000000000; // -0.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n// Cerrar archivo de salida\n$fclose(write_data);\n// Final de simulacion\n$display(\"Test completed\");\n//$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);\nend\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/sumador/","title":"03. Sumador","text":""},{"location":"documentacion/combinacionales/sumador/#que-es-un-sumador","title":"\u00bfQu\u00e9 es un sumador?:","text":"<p>Circuito combinacional que realiza la suma de bits, generalmente realizan las operaciones aritm\u00e9ticas en c\u00f3digo binario, decimal o BCD. En los casos en los que se est\u00e9 empleando un complemento a dos para representar n\u00fameros negativos, el sumador se convertir\u00e1 en un sumador-substractor.   Figura 1.0. Modelo de un sumador de dos entradas.</p>"},{"location":"documentacion/combinacionales/sumador/#sumador-completo","title":"Sumador completo","text":"<p>Suma tres entradas y produce dos salidas. Las primeras dos entradas son A y B; y la tercera entrada es un acarreo de entrada, tambi\u00e9n cuenta con un acarreo en la salida.   Figura 1.0. Representaci\u00f3n de un sumador completo.</p>"},{"location":"documentacion/combinacionales/sumador/#tabla-de-verdad","title":"Tabla de verdad","text":"\\(A\\) \\(B\\) \\(C_{in}\\) \\(Sum\\) \\(C_{out}\\) 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1"},{"location":"documentacion/combinacionales/sumador/#semisumador","title":"Semisumador","text":"<p>Suma dos d\u00edgitos binarios simples A y B, denominados sumandos, y sus salidas son Suma (S) y Acarreo (C). La se\u00f1al del acarreo representa y desbordamiento en el siguiente d\u00edgito en una adici\u00f3n de varios d\u00edgitos.  Dos semisumadores pueden ser combinados para hacer un sumador completo, a\u00f1adiendo una compuerta OR para combinar sus salidas de acarreo. </p> <p> Figura 1.0. Representaci\u00f3n de un semisumador.</p>"},{"location":"documentacion/combinacionales/sumador/#tabla-de-verdad_1","title":"Tabla de verdad","text":"\\(A\\) \\(B\\) \\(C\\) \\(S\\) 0 0 0 0 1 0 0 1 0 1 0 1 1 1 1 0"},{"location":"documentacion/combinacionales/sumador/#implementacion-en-verilog","title":"Implementaci\u00f3n en Verilog","text":"<p>Para ejemplificar el dise\u00f1o y simulaci\u00f3n de un sumador en lenguaje de programaci\u00f3n Verilog, desarrollaremos diferentes propuesta de c\u00f3digo en la que se pudiera observar su implementaci\u00f3n de la forma m\u00e1s sencilla posible:</p> <pre><code>module adder #(\nparameter Width = 32\n) (\ninput signed [Width-1:0] a_i,\ninput signed [Width-1:0] b_i,\noutput signed [Width-1:0] sum_o\n);\nassign sum_o = a_i + b_i;\nendmodule\n</code></pre>"},{"location":"documentacion/combinacionales/sumador/#testbench","title":"Testbench","text":"<p>Simulaci\u00f3n en gtkwave: <pre><code>`timescale 1ns / 100ps\n`include \"adder.v\"\nmodule adder_tb #(\nparameter Width = 32\n) ();\n// Definici\ufffdn de se\ufffdales de entrada y salida\nreg [Width-1:0] a;\nreg [Width-1:0] b;\nwire [Width-1:0] c;\n// Instanciacion del modulo\nadder #(Width) DUT (\n.a_i(a),\n.b_i(b),\n.sum_o(c)\n);\n// Abrir archivo de salida\ninteger write_data;\nlocalparam SF = 2.0**-21.0;\ntime t;\n// Estimulo de las entradas\ninitial begin\nwrite_data = $fopen(\"adder_tb_output.txt\",\"w\");\n$dumpfile(\"adder_tb.vcd\");\n$dumpvars(0,adder_tb);\n$timeformat(-9, 2, \" ns\", 10);\na = 32'b00000000001000000000000000000000; // 1.0\nb = 32'b00000000001000000000000000000000; // 1.0;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b00000000001100000000000000000000; // 1.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\na = 32'b00000000001100000000000000000000; // 1.5\nb = 32'b11111111111100000000000000000000; // -0.5;\n#100; t = $time;\n$fdisplay(write_data, \"Tiempo: %t\\ta = %10.7f\\tb = %10.7f\\tc = %10.7f\",t,$itor(a)*SF,$itor(b)*SF,$itor(c)*SF);\n// Cerrar archivo de salida\n$fclose(write_data);\n// Final de simulacion\n$display(\"Test completed\");\n//$display(\"a = %2d, b = %2d, result = %2d\", a, b, c);\nend\nendmodule\n</code></pre></p>"},{"location":"documentacion/combinacionales/sumador/#referencias","title":"Referencias","text":"<ul> <li>Full Adder in Digital Logic. (2017, marzo 21). GeeksforGeeks. https://www.geeksforgeeks.org/full-adder-in-digital-logic/</li> </ul>"},{"location":"documentacion/instalacion/00_herramientas/","title":"00. Herramientas","text":""},{"location":"documentacion/instalacion/00_herramientas/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Existen diversas maneras para trabajar con Verilog, entre las m\u00e1s populares se encuentran:</p> <ul> <li>Aldec-HDL Student Edition</li> <li>Vivado ML Edition</li> <li>Intel Quartus Prime Lite Edition</li> <li>Icarus Verilog</li> </ul> <p>sin embargo, a pesar de que todas estas opciones son gratuitas, no est\u00e1n disponibles en todos los sistemas operativos, en la siguiente tabla se muestran las diferentes compatibilidades:</p> Tabla 1. Compabilidad en diferentes sistemas operativos. Software Linux Windows Mac Aldec-HDL Student Edition \u2713 Vivado ML Edition \u2713 \u2713 Intel Quartus Prime Lite Edition \u2713 \u2713 Icarus Verilog \u2713 \u2713 \u2713 <p>por lo anterior es buena idea comenzar a aprender Verilog utilizando Icarus Verilog, el cual es un compilador libre (open source) para el lenguaje de descripci\u00f3n de hardware IEEE-1364 Verilog. A diferencia de las otras opciones los cuales cuentan con GUI y programas adicionales, Icarus Verilog funciona desde terminal y solo cuenta con herramientas para analizar, compilar y simular el c\u00f3digo Verilog, lo cual es m\u00e1s que suficiente. Las principales ventajas que cuenta esta herramienta son: 1) es muy ligera y f\u00e1cil de instalar, 2) es compatible con diversos sistemas operativos y 3) su compilador es muy robusto, otras herramientas son m\u00e1s permisivas con los errores en el c\u00f3digo.</p> <p>La ventaja de instalar Vivado ML Edition o Intel Quartus Prime Lite Edition es que cuentan con todas las herramientas necesarias para llevar el flujo de dise\u00f1o en FPGA.</p> <pre><code>flowchart LR\n  A[Especificaciones] ==&gt; B[HDL];\n  B ==&gt; C[S\u00edntesis];\n  C ==&gt; D[Place and Route];\n  D ==&gt; E[Verificaci\u00f3n del circuito];\n  B -.-&gt; F[Simulaci\u00f3n];\n  D -.-&gt; G[An\u00e1lisis de tiempo est\u00e1tico];</code></pre>"},{"location":"documentacion/instalacion/00_herramientas/#2-instalacion-de-herramientas","title":"2. Instalaci\u00f3n de herramientas","text":"<p>Para comenzar a trabajar con Icarus Verilog es necesario instalar los siguientes programas:</p> <ul> <li>Instalar un compilador de verilog, Icarus Verilog es el m\u00e1s popular. <ul> <li>Para windows  <code>scoop install iverilog</code></li> <li>Para macOS  <code>brew install icarus-verilog</code></li> </ul> </li> <li>Instalar un visualizador de forma de onda para verilog. GTKwave es una muy buena opci\u00f3n.<ul> <li>Para Windows ya vienen preinstalado con Icarus.</li> <li>Para macOS basta con entrar al siguiente enlace e instalar.</li> </ul> </li> <li>Crear los c\u00f3digos  <code>circuit.v</code> y su archivo de simulaci\u00f3n <code>circuit_tb.v</code></li> <li>En el archivo de simulaci\u00f3n es necesario incluir: <pre><code>`timescale 1ns / 100 ps\n`include \"circuit.v\"\ninitial begin\n$dumpfile(\"circuit_tb.vcd\");\n$dumpvars(0, circuit_tb);\n$display(\"Test complete\");\nend\n</code></pre></li> <li>Los comandos a ejecutar son: <pre><code>iverilog -o circuit_tb.vvp circuit_tb.v\nvvp circuit_tb.vvp\nstart gtkwave\n</code></pre></li> </ul> <p> </p> Figura 1. Nombre de la imagen. <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"documentacion/instalacion/00_herramientas/#links-utiles","title":"links utiles","text":"<ul> <li>Uso de <code>$dumpvars</code> en el enlace</li> <li>C\u00f3mo instalar las herramientas Icarus y GTKwave, video</li> <li>Ejemplo de como utilizar Icarus y GTKwave, video</li> <li>Articulo de c\u00f3mo instalar en macOS, enlace</li> <li>Pagina de verilog, enlace</li> </ul>"},{"location":"documentacion/instalacion/01_automatizacion/","title":"01. Scripts","text":""},{"location":"documentacion/instalacion/01_automatizacion/#instalacion","title":"Instalaci\u00f3n","text":"<ul> <li>Instalar un compilador de verilog, Icarus Verilog es el m\u00e1s popular. <ul> <li>Para windows  <code>scoop install iverilog</code></li> <li>Para macOS  <code>brew install icarus-verilog</code></li> </ul> </li> <li>Instalar un visualizador de forma de onda para verilog. GTKwave es una muy buena opci\u00f3n.<ul> <li>Para Windows ya vienen preinstalado con Icarus.</li> <li>Para macOS basta con entrar al siguiente enlace e instalar.</li> </ul> </li> <li>Crear los c\u00f3digos  <code>circuit.v</code> y su archivo de simulaci\u00f3n <code>circuit_tb.v</code></li> <li>En el archivo de simulaci\u00f3n es necesario incluir: <pre><code>`timescale 1ns / 100 ps\n`include \"circuit.v\"\ninitial begin\n$dumpfile(\"circuit_tb.vcd\");\n$dumpvars(0, circuit_tb);\n$display(\"Test complete\");\nend\n</code></pre></li> <li>Los comandos a ejecutar son: <pre><code>iverilog -o circuit_tb.vvp circuit_tb.v\nvvp circuit_tb.vvp\nstart gtkwave\n</code></pre></li> </ul>"},{"location":"documentacion/instalacion/01_automatizacion/#links-utiles","title":"links utiles","text":"<ul> <li>Uso de <code>$dumpvars</code> en el enlace</li> <li>C\u00f3mo instalar las herramientas Icarus y GTKwave, video</li> <li>Ejemplo de como utilizar Icarus y GTKwave, video</li> <li>Articulo de c\u00f3mo instalar en macOS, enlace</li> </ul>"},{"location":"documentacion/secuenciales/","title":"Secuencial","text":""},{"location":"documentacion/secuenciales/contador/","title":"00. Flip-Flop","text":""},{"location":"documentacion/secuenciales/contador/#referencias","title":"Referencias","text":"<ul> <li>Flip Flop tipo D con reset y eneable Verilog. (s/f). Gist. Recuperado el 12 de julio de 2023, de https://gist.github.com/davilamds/937b372d27bb91ab399123f9d6da1baf</li> <li>D Flip Flop in Digital Electronics\u2014Javatpoint. (s/f). Recuperado el 12 de julio de 2023, de https://www.javatpoint.com/d-flip-flop-in-digital-electronics</li> </ul>"},{"location":"documentacion/secuenciales/flipflop/","title":"00. Flip-Flop","text":""},{"location":"documentacion/secuenciales/flipflop/#referencias","title":"Referencias","text":"<ul> <li>Flip Flop tipo D con reset y eneable Verilog. (s/f). Gist. Recuperado el 12 de julio de 2023, de https://gist.github.com/davilamds/937b372d27bb91ab399123f9d6da1baf</li> <li>D Flip Flop in Digital Electronics\u2014Javatpoint. (s/f). Recuperado el 12 de julio de 2023, de https://www.javatpoint.com/d-flip-flop-in-digital-electronics</li> </ul>"},{"location":"documentacion/secuenciales/fsm_mealy/","title":"00. Flip-Flop","text":""},{"location":"documentacion/secuenciales/fsm_mealy/#referencias","title":"Referencias","text":"<ul> <li>Flip Flop tipo D con reset y eneable Verilog. (s/f). Gist. Recuperado el 12 de julio de 2023, de https://gist.github.com/davilamds/937b372d27bb91ab399123f9d6da1baf</li> <li>D Flip Flop in Digital Electronics\u2014Javatpoint. (s/f). Recuperado el 12 de julio de 2023, de https://www.javatpoint.com/d-flip-flop-in-digital-electronics</li> </ul>"},{"location":"documentacion/secuenciales/fsm_moore/","title":"00. Flip-Flop","text":""},{"location":"documentacion/secuenciales/fsm_moore/#referencias","title":"Referencias","text":"<ul> <li>Flip Flop tipo D con reset y eneable Verilog. (s/f). Gist. Recuperado el 12 de julio de 2023, de https://gist.github.com/davilamds/937b372d27bb91ab399123f9d6da1baf</li> <li>D Flip Flop in Digital Electronics\u2014Javatpoint. (s/f). Recuperado el 12 de julio de 2023, de https://www.javatpoint.com/d-flip-flop-in-digital-electronics</li> </ul>"},{"location":"documentacion/teoria/","title":"Te\u00f3ria","text":""},{"location":"documentacion/teoria/fixed_point/","title":"03. Aritm\u00e9tica de punto fijo","text":""},{"location":"documentacion/teoria/fixed_point/#complemento-a-1","title":"Complemento a 1","text":"<p>El complemento a 1 consiste en invertir todos los 1s por 0s y todos los 0s por 1s de todo el n\u00famero binario. Ejemplo: \\(1010 1111\\) y su complemento a 1 es \\(01010000\\).</p>"},{"location":"documentacion/teoria/fixed_point/#complemento-a-2","title":"Complemento a 2","text":"<p>El complemento a 2 consiste en realizar el complemento a 1 y posteriormente sumar un 1. Ejemplo: \\(1010 1111\\) entonces su complemento a 2 se calcula primero ejecutando el complemento a 1, \\(0101 0000\\) y sumando un 1 al resultado anterior obtenemos \\(0101 0001\\)</p>"},{"location":"documentacion/teoria/fixed_point/#punto-fijo","title":"Punto Fijo","text":"<p>Un n\u00famero de punto fijo tiene la forma \\(A(a,b)\\) donde \\(a\\) es la parte entera, y \\(b\\)  es la parte fraccionaria. El n\u00famero de bits que tienen \\(A(a,b)\\) es \\(\\text{nbits} = a+b+1\\), de manera que es la suma de la parte entera m\u00e1s la parte fraccionaria m\u00e1s un bit de signo. El rango de n\u00fameros que se pueden representar es \\([-2^{a}, 2^{a} - 2^{-b}]\\). Esta representaci\u00f3n trabaja con una l\u00f3gica aritm\u00e9tica de complemento a 2.</p> N\u00famero Representaci\u00f3n Valor en decimal Rango Valor decimal sin signo <code>0000 1000</code> \\(A(3,4)\\) 0.5 \\([-8.0, 7.9375]\\) 8 <code>0000 1100</code> \\(A(3,4)\\) 0.75 \\([-8.0, 7.9375]\\) 12 <code>0111 0011</code> \\(A(3,4)\\) 7.1875 \\([-8.0, 7.9375]\\) 115 <code>1001 0000</code> \\(A(2,5)\\) -3.5 \\([-4.0,3.96875]\\) 144 <code>1001 0000</code> \\(A(3,4)\\) -7.0 \\([-8.0, 7.9375]\\) 144"},{"location":"documentacion/teoria/scm/","title":"03. SCM","text":""},{"location":"documentacion/teoria/scm/#single-constant-multiplication-scm","title":"Single constant multiplication (SCM)","text":""},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#1-introduccion","title":"1. Introducci\u00f3n","text":"<p>Existen diversas maneras para trabajar con Verilog, entre las m\u00e1s populares se encuentran:</p> <ul> <li>Aldec-HDL Student Edition</li> <li>Vivado ML Edition</li> <li>Intel Quartus Prime Lite Edition</li> <li>Icarus Verilog</li> </ul> <p>sin embargo, a pesar de que todas estas opciones son gratuitas, no est\u00e1n disponibles en todos los sistemas operativos, en la siguiente tabla se muestran las diferentes compatibilidades:</p> Tabla 1. Compabilidad en diferentes sistemas operativos. Software Linux Windows Mac Aldec-HDL Student Edition \u2713 Vivado ML Edition \u2713 \u2713 Intel Quartus Prime Lite Edition \u2713 \u2713 Icarus Verilog \u2713 \u2713 \u2713 <p>por lo anterior es buena idea comenzar a aprender Verilog utilizando Icarus Verilog, el cual es un compilador libre (open source) para el lenguaje de descripci\u00f3n de hardware IEEE-1364 Verilog. A diferencia de las otras opciones los cuales cuentan con GUI y programas adicionales, Icarus Verilog funciona desde terminal y solo cuenta con herramientas para analizar, compilar y simular el c\u00f3digo Verilog, lo cual es m\u00e1s que suficiente. Las principales ventajas que cuenta esta herramienta son: 1) es muy ligera y f\u00e1cil de instalar, 2) es compatible con diversos sistemas operativos y 3) su compilador es muy robusto, otras herramientas son m\u00e1s permisivas con los errores en el c\u00f3digo.</p> <p>La ventaja de instalar Vivado ML Edition o Intel Quartus Prime Lite Edition es que cuentan con todas las herramientas necesarias para llevar el flujo de dise\u00f1o en FPGA.</p> <pre><code>flowchart LR\n  A[Especificaciones] ==&gt; B[HDL];\n  B ==&gt; C[S\u00edntesis];\n  C ==&gt; D[Place and Route];\n  D ==&gt; E[Verificaci\u00f3n del circuito];\n  B -.-&gt; F[Simulaci\u00f3n];\n  D -.-&gt; G[An\u00e1lisis de tiempo est\u00e1tico];</code></pre>"},{"location":"getting_started/#2-instalacion-de-herramientas","title":"2. Instalaci\u00f3n de herramientas","text":"<p>Para comenzar a trabajar con Icarus Verilog es necesario instalar los siguientes programas:</p> <ul> <li>Instalar un compilador de verilog, Icarus Verilog es el m\u00e1s popular. </li> <li>Para windows  <code>scoop install iverilog</code></li> <li>Para macOS  <code>brew install icarus-verilog</code></li> <li>Instalar un visualizador de forma de onda para verilog. GTKwave es una muy buena opci\u00f3n.</li> <li>Para Windows ya vienen preinstalado con Icarus.</li> <li>Para macOS basta con entrar al siguiente enlace e instalar.</li> <li>Crear los c\u00f3digos  <code>circuit.v</code> y su archivo de simulaci\u00f3n <code>circuit_tb.v</code></li> <li>En el archivo de simulaci\u00f3n es necesario incluir:</li> </ul> <pre><code>`timescale 1ns / 100 ps\n`include \"circuit.v\"\ninitial begin\n$dumpfile(\"circuit_tb.vcd\");\n$dumpvars(0, circuit_tb);\n$display(\"Test complete\");\nend\n</code></pre> <ul> <li>Los comandos a ejecutar son:</li> </ul> <pre><code>iverilog -o circuit_tb.vvp circuit_tb.v\nvvp circuit_tb.vvp\nstart gtkwave\n</code></pre> <p> </p> Figura 1. Nombre de la imagen. <p>Note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"getting_started/#links-utiles","title":"links utiles","text":"<ul> <li>Uso de <code>$dumpvars</code> en el enlace</li> <li>C\u00f3mo instalar las herramientas Icarus y GTKwave, video</li> <li>Ejemplo de como utilizar Icarus y GTKwave, video</li> <li>Articulo de c\u00f3mo instalar en macOS, enlace</li> <li>Pagina de verilog, enlace</li> </ul>"},{"location":"proyectos/","title":"Proyectos","text":""},{"location":"proyectos/FIR/","title":"FIR","text":""}]}